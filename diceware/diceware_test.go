package diceware

import (
	"reflect"
	"strconv"
	"testing"
)

func TestDecodeDiceValue(t *testing.T) {

	tests := []struct {
		name string
		p    uint
		buf  []byte
		r    uint8
	}{
		{
			name: "Position 0, value 7",
			p:    0,
			buf:  []byte{0xE0, 0x00},
			r:    7,
		},
		{
			name: "Position 3, value 7",
			p:    3,
			buf:  []byte{0x1C, 0x00},
			r:    7,
		},
		{
			name: "Position 6, value 7",
			p:    6,
			buf:  []byte{0x03, 0x80},
			r:    7,
		},
		{
			name: "Position 9, value 7",
			p:    9,
			buf:  []byte{0x00, 0x70},
			r:    7,
		},
		{
			name: "Position 12, value 7",
			p:    12,
			buf:  []byte{0x00, 0x0E},
			r:    7,
		},
		// Decoding a dice value 1 split on two bytes
		{
			name: "Position 6, value 1",
			p:    6,
			buf:  []byte{0x00, 0x80},
			r:    1,
		},
		// Decoding a dice value 1 split on two bytes should not pick a bit around
		{
			name: "Position 6, value 1",
			p:    6,
			buf:  []byte{0xFC, 0x8F},
			r:    1,
		},
		// Decoding a dice value 1 split on two bytes
		{
			name: "Position 7, value 1",
			p:    7,
			buf:  []byte{0x00, 0x40},
			r:    1,
		},
	}
	var h dwHash
	for _, tt := range tests {
		r := h.decodeDiceValue(tt.p, tt.buf)
		if r != tt.r {
			t.Errorf("%v: return %d. Expected %d", tt.name, r, tt.r)
		}

	}
}

func TestDecodeWordNumber(t *testing.T) {
	tests := []struct {
		name string
		s    uint
		h    dwHash
		n    uint
		d    []uint8
	}{
		{
			name: "All zero",
			s:    0,
			h:    [...]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			n:    255,
			d:    []uint8{},
		},
		{
			name: "All 1",
			s:    0,
			h:    [...]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
			n:    255,
			d:    []uint8{},
		},
		{
			name: "All zero but last bit is 1",
			s:    0,
			h:    [...]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02},
			n:    255,
			d:    []uint8{1},
		},
		{
			name: "All dices value is 1",
			s:    0,
			h:    [...]byte{0x24, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0x92},
			n:    15,
			d:    []uint8{1, 1, 1, 1, 1},
		},
		{
			name: "Five 1 dices at the beginning",
			s:    0,
			h:    [...]byte{0x24, 0x92, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			n:    15,
			d:    []uint8{1, 1, 1, 1, 1},
		},
		{
			name: "Five 1 dices at the end",
			s:    0,
			h:    [...]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x92},
			n:    255,
			d:    []uint8{1, 1, 1, 1, 1},
		},
		{
			name: "Five 1 dices randomly inserted",
			s:    0,
			h:    [...]byte{0x00, 0x10, 0x01, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			n:    159,
			d:    []uint8{1, 1, 1, 1, 1},
		},
		{
			name: "Five 1 dices randomly inserted, start just before 1st one",
			s:    11,
			h:    [...]byte{0x00, 0x10, 0x01, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			n:    161,
			d:    []uint8{4, 4, 4, 4, 4},
		},
		{
			name: "Five 1 dices randomly inserted, start just after 1st one",
			s:    12,
			h:    [...]byte{0x00, 0x10, 0x01, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			n:    255,
			d:    []uint8{1, 1, 1, 1},
		},
		{
			name: "Five 1 dices randomly inserted, start just before the last one",
			s:    158,
			h:    [...]byte{0x00, 0x10, 0x01, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			n:    254,
			d:    []uint8{4},
		},
		{
			name: "Two 6 dices",
			s:    36,
			h:    [...]byte{0x00, 0x00, 0x00, 0x00, 0x0D, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			n:    255,
			d:    []uint8{6, 6},
		},
	}
	for _, tt := range tests {
		n, d := tt.h.decodeWordNumber(tt.s)
		if !(n == tt.n && reflect.DeepEqual(d, tt.d)) {
			t.Errorf("%v: return %d, %v. Expected %d, %v", tt.name, n, d, tt.n, tt.d)
		}

	}
}

type itoaHash struct {
	dwHash
}

func (h *itoaHash) findWords() ([]string, []int) {

	s := uint(0)
	pp := []string{}
	ppn := []int{}
	number := 0
	for {
		s, number = h.decodeWord(s)
		if number == 0 {
			// no more word available in this hash
			break
		}
		pp = append(pp, h.word(number))
		ppn = append(ppn, number)
	}
	return pp, ppn
}

func (h *itoaHash) word(number int) string {

	return strconv.Itoa(number)
}

func newItoaHash(h dwHash) itoaHash {

	return itoaHash{h}
}

func TestFindWordsWithStub(t *testing.T) {

	tests := []struct {
		name string
		h    itoaHash
		pp   []string
		ppn  []int
	}{
		{
			name: "Word 12345",
			h:    newItoaHash([...]byte{0x29, 0xCA, 0x00, 0x29, 0xCA, 0x00, 0x29, 0xCA, 0x00, 0x29, 0xCA, 0x00, 0x29, 0xCA, 0x00, 0x29, 0xCA, 0x01, 0x20, 0x90, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}),
			pp:   []string{"12345", "12345", "12345", "12345", "12345", "12345", "11111"},
			ppn:  []int{12345, 12345, 12345, 12345, 12345, 12345, 11111},
		},
		{
			name: "Word 11111",
			h:    newItoaHash([...]byte{0x24, 0x82, 0x40, 0x24, 0x82, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}),
			pp:   []string{"11111", "11111"},
			ppn:  []int{11111, 11111},
		},
	}
	for _, tt := range tests {
		pp, ppn := tt.h.findWords()
		if !(reflect.DeepEqual(pp, tt.pp) && reflect.DeepEqual(ppn, tt.ppn)) {
			t.Errorf("%v: return %v, %v. Expected %v, %v", tt.name, pp, ppn, tt.pp, tt.ppn)
		}

	}
}

func TestFindWords(t *testing.T) {

	tests := []struct {
		name string
		h    dwHash
		pp   []string
		ppn  []int
	}{
		{
			name: "Word 12345",
			h:    [...]byte{0x29, 0xCA, 0x00, 0x29, 0xCA, 0x00, 0x29, 0xCA, 0x00, 0x29, 0xCA, 0x00, 0x29, 0xCA, 0x00, 0x29, 0xCA, 0x02, 0x42, 0x40, 0x82, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			pp:   []string{"apathy", "apathy", "apathy", "apathy", "apathy", "apathy", "dear"},
			ppn:  []int{12345, 12345, 12345, 12345, 12345, 12345, 22442},
		},
	}
	for _, tt := range tests {
		pp, ppn := tt.h.findWords("en")
		if !(reflect.DeepEqual(pp, tt.pp) && reflect.DeepEqual(ppn, tt.ppn)) {
			t.Errorf("%v: return %v, %v. Expected %v, %v", tt.name, pp, ppn, tt.pp, tt.ppn)
		}

	}
}

func TestPassphrase(t *testing.T) {

	tests := []struct {
		name string
		l    int
		e    []byte
		lang string
	}{
		{
			name: "9 words passphrase",
			l:    9,
			e:    entropy(32),
			lang: "en",
		},
		{
			name: "30 words passphrase",
			l:    30,
			e:    entropy(32),
			lang: "en",
		},
	}
	for _, tt := range tests {
		pp, ppn := Passphrase(tt.l, tt.e, tt.lang)
		if len(pp) != tt.l || len(ppn) != tt.l {
			t.Errorf("%v: return %v, %v. Expected %v, %v", tt.name, len(pp), len(ppn), tt.l, tt.l)
		}

	}
}
